For NUMTYPE:
X	Mathematical Operators: (For Type NUMBER only.)
X		Operator += (Done)
X		Operator -= (Done)
X		Operator *= (Done)
X		Operator /= (Done)
X		Operator + (Made static function 'add')
X		Operator - (Made static function 'subtract')
X		Operator * (Made static function 'multiply')
X		Operator / (Made static function 'divide')
X		Operator % (Made static function 'mod')

X	Comparison Operators: (For Type NUMBER only.)
X		Operator == (Returns c++ bool)
X		Operator != (Returns c++ bool)
X		Operator < (Returns c++ bool)
X		Operator > (Returns c++ bool)
X		Operator <= (Returns c++ bool)
X		Operator >= (Returns c++ bool)


For BOOLTYPE:
	Logical Operators: (For Type BOOLEAN only.)
		Operator !
		Operator &&
		Operator ||

X	Get c++ bool from BoolType (done. Made function getBoolValue().)


For STRINGTYPE:
X	String Operators: (For Type STRING only.)
X		Operator += (Done)
X		Operator + (Made static function add)


For JSONTYPE:
	Subtract


ListType:
	Subtract


Other:
	Type NULL
	File read
	File write
	MakeString
	TypeStruct
	Pretty Print
	Type Checking

	Parse JSON should not print
	Parse LIST should not print
X	Parse NUMBER should work for negative numbers and decimals.


QUESTIONS:
	Do we need to overwrite the BoolType Logical Operators? It is highly recommend that you never do this. The main reason being, is the logical operators for booleans short-circuit and 
you can't get this behavior when overloading. The recommended way of dealing with this is to create an operator to convert to a bool and perform the logic on the bool. We are already 
providing this operator with getboolValue(). I think it would be better if we change our OCaml rather than our c++ here. Let me know if there is a case where I am wrong here.

	Similar to above, do the Comparison Operators need to return a BoolType? Or can we have them return a bool? Returning a bool prevents the problems I was having earlier with c++ not being able to downcast a pointer.
